
/**
 *		=> 객체 지향 프로그램
 *			장점
 *				코드 재사용 :	상속 / 포함
 *				유지 보수시에 사용이 용이
 *				대형 프로젝트에서 주로 사용 :	금융권 / 증권 / 공기업(국세청, 국민연금) 
 *				=>	클래스 단위로 모듈화 =>	업무 분담이 용이 
 *					회원관련 / 게시판 / 예약 / ...
 *			딘점
 *				처리 속도가 상대적으로 느리다 =>	독립적으로 사용 =>	POJO 방식
 *											----------- 
 *											|	상속 
 *											|	인터페이스 :	연결 
 *				=> 결합성이 높다 =>	클래스 수정시에 다른 클래스에 영향 
 *					-------- 스프림(로드 존슨) 
 *				객체가 많으면 용량이 커질 수 있다(메모리에 부하) 
 *				설계시에 많은 시간이 투자 
 *		-------------------------------------------------------------
 *			개발 =>	7개월	 
 *				3개월 :	요구사항 분석	 
 *				1개월 :	데이터베이스 설계	 
 *				1개월 :	화면 UI	 
 *				2개월 :	구현 =>	테스트	 
 *			---------------------------
 *			CBD	=> 	컴포헌트 베이스	 
 *					----- 만들어진 기능을 조립	 
 *			=>	프로그램머 : 자바	 
 *			=>	개발자 :	컴포넌트 개발	 
 *			this / this() =>
 *			this =>	클래스 자신의 메모리 주소를 설정
 *			----	멤버변수와 지역변수가 같은 경우 구분
 *			----	JVM =>	객체 생성될 때 자동으로 주소값을 저장
 *			----	모든 멤버 관련 =>	메서드, 변수 앞에 반드시 this.
 *					최근에는 this. 생략 =>	컴파일러에 의해 자동 설정
 *
 *					컴파일러가 자동 처리
 *					=> import java.lang.*;
 *					=> 모든 클래스는 Object 상속
 *					class A extends Object
 *							--------------
 *					=> 메서드 안에서 void =>	return 추가
 *					=> 생성자를 사용하지 않으면 디폴트 생성자 추가
 *					=> this.를 생략시에 자동 추가
 *					=> 생략이 가능
 *			this() =>	자신 클래스의 생성자를 호출시에 주로 사용
 *			------	사용빈도는 거의 없다
 *			= 사용위치 =>	생성자 안에서 다른 생성자를 호출할 때 사용		
 *						생성자의 첫줄에 위치		
 *						=>	문법상에 오류 발생
 *
 *		122 page 객체 생성과 사용
 *		=> 객체의 생명주기 (생성~소멸)
 *						-------	처리 (스프링 =>	클래스 관리자)
 *		=> new 이용하면 결합성 높은 프로그램 -> 사용을 지양
 *			--- 객체 생성 방법이 있다 =>	리플렉션 (클래스명만 있으면 처리가 가능)
 *									------
 *									스프링 =>	스프링 가능자
 *									
 *		=> class A
 *			{
 *				int a;
 *				double d:
 *				static int b;
 *				void disp() {};
 *			}
 *
 *			MethodArea
 *			--b--
 *			  0		=> 모든 객체가 접근이 가능 =>	공유변수
 *			-----		aa.b, bb.b, ....
 *
 *			A aa = new A();
 *			
 *			Stack
 *			--aa--
 *			0x100
 *			------
 *							Heap
 *					0x100	---------
 *							--a--
 *							  0		==> aa.a
 *							-----
 *							---------
 *							--d--
 *							  0.0	==> aa.d
 *							-----
 *							---------
 *							disp()	==>	aa.disp()
 *							---------
 *			A bb = new A();
 *			
 *			Stack
 *			--bb--
 *			0x200
 *			------
 *							Heap
 *					0x200	---------
 *							--a--
 *							  0		==> bb.a
 *							-----
 *							---------
 *							--d--
 *							  0.0	==> bb.d
 *							-----
 *							---------
 *							disp()	==>	bb.disp()
 *							---------
 *
 *			설계(작성)	  =====>	메모리 저장 =====> 활용 ======> 메모리 회수
 *			class ClassName	=>	new 생성자()		===			null
 *			{									.메서드()
 *				변수 / 메서드 / 생성자				.변수명
 *			}		
 *			*** 변수만 가지고 있는 경우
 *				=>	데이터형 클래스 (사용자 정의 데이터형)
 *					=>	관련된 데이터를 모아서 한번에 관리
 *			*** 메서드만 가지고 있는 경우
 *			*** 변수+메서드
 *			=>	관련된 내용을 모아서 관리 (잘 묶는가?)
 *			=>	관리 =>	데이터(상태) 관리
 *						-------- 변수 / 배열 / 클래스 / 파일 / RDBMS
 *								웹 / 모바일 =>	한번에 전송
 *
 *		=> 	1) 메서드	2) 접근지정어	3) 상속	4) 포함			 
 *			5) 클래스의 종류 (추상클래스, 인터페이스)			 
 *		=> 	예외처리 =>	라이브러리 (Collection, IO, SQL, NetWork)			 
 *		=> 	프로젝트 / 오라클 =>	시작 크롤링			 
 *		=> 	브라우저 (HTML/CSS/JavaScript)			 
 *		=> 	서버연결 =>	JSP (1차)	
 *		=>	스프링 (2차) =>	파이썬 (데이터분석), ElasticSearch		 
 */
class A
{
	void disp(int a)
	{
		System.out.println("dis() Call " + a);
	}
}
public class 객체지향_1 {

	public static void main(String[] args) {
		// TODO Auto-generated method stub
		A aa=new A();
		aa.disp(100);
		A bb=new A();
		bb.disp(1000);
		/*
		 * 	=>	123 page
		 *  A aa;		// 선언
		 *  
		 *  aa=new A();	// 저장
		 *  
		 *  A aa=new A();	// 선언과 동시에 저장
		 */
	}

}
